classdef Warper

    properties (SetAccess = private)
        %InputSize Expected input image size
        %  The InputSize specifies the first two or three dimensions of the
        %  input image that the warper supports.
        InputSize = [];

        %OutputSize Output size of the warped image
        %  The OutputSize specified the first two dimensions of the output
        %  image generated by the application of the geometrical transform.
        OutputSize = [];

        %Interpolation String specifying the interpolation method
        % Value is one of:
        %   'nearest' - nearest-neighbor interpolation
        %   'linear'  - linear interpolation
        %   'cubic'   - cubic interpolation
        Interpolation = [];

        %FillValue Fill value used for out-of-bound pixel locations
        %  The FillValue is a scalar numeric value specifying the value to
        %  use for a input pixel location that is outside the bounds of
        %  the input image. FillValue is cast to the datatype of the input
        %  image before use.
        FillValue = [];
    end

    properties (Access = private)
        UseIPP = true;
        SourceX = [];
        SourceY = [];
    end

    methods
        function warper = Warper(varargin)
            narginchk(2, 7);
            [tform, sourceSizeOrRef, OutputReference, FillValue, Interpolation, sourceX, sourceY] ...
                = warper.parseInputs(varargin{:});

            if isempty(sourceX)
                % Compute coordinate transform from tform and input ref/size
                if isa(sourceSizeOrRef,'imref2d')
                    warper.InputSize = sourceSizeOrRef.ImageSize;
                    refIn  = sourceSizeOrRef;
                else
                    % Pick only first two dimensions
                    warper.InputSize = sourceSizeOrRef(1:2);
                    refIn  = imref2d(warper.InputSize);
                end

                if isempty(OutputReference)
                    OutputReference = images.spatialref.internal.applyGeometricTransformToSpatialRef(refIn,tform);
                end
                [sourceX, sourceY] = images.geotrans.internal.getSourceMappingInvertible2d(refIn, tform, OutputReference);
            end

            warper.UseIPP = images.internal.useIPPLibrary;
            if warper.UseIPP
                % Convert to zero-based indexing for IPP
                sourceX = sourceX-1;
                sourceY = sourceY-1;
            end

            warper.SourceX = single(sourceX);
            warper.SourceY = single(sourceY);
            warper.Interpolation = Interpolation;
            warper.OutputSize = size(sourceX);
            warper.FillValue = FillValue;
        end

        function out = warp(warper, im)
            %WARP Apply the geometric transformation
            %  B = warper.warp(A) performs the geometrical
            %  transformation on the input image A and returns the warped
            %  image in B. A has to be of size inputSize.
            %
            %  Class Support
            %  -------------
            %  warper is an object of type images.geotrans.Warper. A has to
            %  be a numeric matrix of either uint8, int16 or single
            %  datatype, with size [M, N] or [M, N, P]. B has the same type
            %  as A and its first two dimensions are warper.OutputSize. If
            %  A has P planes, B will also have P planes.
            %

            if ~isa(im,'uint8') && ~isa(im,'int16') && ~isa(im,'single')
                error(message('images:validate:unsupportedDataType','uint8, int16, single'));
            end
            if ~(ndims(im)<4)
                % Had to be 2d or 3d
                error(message('images:Warper:expected2or3d'))
            end
            if ~isempty(warper.InputSize) && ~isequal([size(im,1), size(im,2)], warper.InputSize)
                % Check image size only if tform/inputsize is given.
                error(message('images:Warper:inconsistentSize'))
            end

            inClass = class(im);
            if isa(im, 'int16')
                im = single(im);
            end

            if warper.UseIPP
                % Prepare fill value
                fillValue = cast(warper.FillValue, 'like', im);
                fillValue = repmat(fillValue, [1, size(im,3)]);

                out = images.internal.builtins.remap( im,...
                                        warper.SourceX, warper.SourceY,...
                                        warper.Interpolation, fillValue );
            else
                out = zeros([warper.OutputSize, size(im,3)],'single');
                for pInd = 1:size(im,3)
                    f = griddedInterpolant({1:size(im,1), 1:size(im,2)}, single(im(:,:,pInd)));
                    f.Method = warper.Interpolation;
                    f.ExtrapolationMethod = 'none';
                    out(:,:,pInd) = f(warper.SourceY, warper.SourceX);
                end
                out(isnan(out)) = warper.FillValue;
            end

            out = cast(out, inClass);
        end
    end

    methods (Access = private)
        function [tform, sourceSizeOrRef, OutputReference, FillValue, Interpolation, sourceX, sourceY] = parseInputs(~, varargin)
            args = matlab.images.internal.stringToChar(varargin);

            parser = inputParser;

            parser.CaseSensitive = false;
            parser.PartialMatching = true;

            if isnumeric(args{1})
                parser.addRequired('sourceX', @(parm)checkSourceXY(parm, 'sourceX'));
                parser.addRequired('sourceY', @(parm)checkSourceXY(parm, 'sourceY'));
            else
                parser.addRequired('tform',@checktform);
                parser.addRequired('sourceSizeOrRef', @checksourceSizeOrRef);
                parser.addOptional('OutputReference',imref2d.empty(), @checkOutputRef);
            end

            parser.addParameter('FillValue',uint8(0), @checkFillValues);
            parser.addParameter('Interpolation', 'linear', @checkInterpolation);
            parser.parse(args{:});
            parsedResults = parser.Results;
            parsedResults.Interpolation = validatestring(parser.Results.Interpolation,...
                {'nearest', 'linear', 'cubic'}, mfilename);

            if isnumeric(args{1})
                tform = [];
                sourceSizeOrRef = [];
                sourceX = parsedResults.sourceX;
                sourceY = parsedResults.sourceY;
            else
                tform = parsedResults.tform;

                % Convert some geometric transformations to the new types
                % introduced in R2022b. Prior to R2022b, the only supported
                % geometric transformation types were affine2d and
                % projective2d.
                if isa(tform,'affine2d')
                    tform = affinetform2d(tform.T');
                elseif isa(tform,'projective2d')
                    tform = projtform2d(tform.T');
                end

                sourceSizeOrRef = parsedResults.sourceSizeOrRef;
                sourceX = [];
                sourceY = [];
            end

            if isnumeric(args{1})
                % If srcX/Y is given, no output ref is required (size of
                % srcX/Y is the output size)
                OutputReference = [];
            else
                OutputReference = parsedResults.OutputReference;
            end

            FillValue = parsedResults.FillValue;
            Interpolation = char(parsedResults.Interpolation);
        end
    end

    methods(Access=private, Static)
        function name = matlabCodegenRedirect(~)
            name = 'images.internal.coder.Warper';
        end

    end
end




%% Validation functions
function tf = checktform(tform)

% Prior to R2022b, tform was restricted to be affine2d or projective2d.
validateattributes(tform,...
    {'transltform2d','rigidtform2d','simtform2d','affinetform2d',...
        'projtform2d','affine2d', 'projective2d'},...
    {'scalar'}, ...
    mfilename, 'tform');
tf = true;
end

function tf = checksourceSizeOrRef(sourceSizeOrRef)

if isa(sourceSizeOrRef,'imref3d')
    error(message('images:Warper:imref3dNotSupported'));
end

if isa(sourceSizeOrRef,'imref2d')
    validateattributes(sourceSizeOrRef,...
        {'imref2d'},...
        {'scalar'},...
        mfilename, 'InputReference');
else
    % MXN, or MxNxP
    validateattributes(sourceSizeOrRef,...
        {'numeric'},...
        {'nonsparse','integer', 'positive', 'finite', 'nonempty'},...
        mfilename, 'InputSize');
    coder.internal.errorIf(~(numel(sourceSizeOrRef)<4),...
        'images:Warper:expected2or3d');
end
tf = true;
end

function tf = checkSourceXY(srcxy, varName)
validateattributes(srcxy,...
    {'single'},...
    {'2d','finite','nonempty'},...
    mfilename, varName);
tf = true;
end

function tf = checkOutputRef(outputRef)

if isa(outputRef,'imref3d')
    error(message('images:Warper:imref3dNotSupported'));
end

validateattributes(outputRef,...
    {'imref2d'},...
    {'scalar'},...
    mfilename, 'OutputReference');
tf = true;
end

function tf = checkInterpolation(interpString)
validateattributes(interpString,...
    {'char','string'},...
    {'scalartext'},...
    mfilename,'Interpolation');
tf = true;
end

function tf = checkFillValues(fillValue)
validateattributes(fillValue,...
    {'numeric'},...
    {'scalar', 'real'}, ...
    mfilename, 'FillValue');
tf = true;
end

% Copyright 2017-2022 The MathWorks, Inc.
